<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inf√¢ncia do GPT ‚Äî N√≠vel 0 (Tutorial)</title>

  <!-- Google Fonts: Lora -->
  <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Matter.js (CDN) -->
  <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>

  <style>
    :root{
      --paper:#f1e9d6;          /* papel */
      --turquoise:#20b2aa;      /* aproxima√ß√£o */
      --orange:#f3852e;         /* giz laranja */
      --brown:#8a5a3b;          /* couro/marrom */
      --ink:#2a2a2a;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:#e8e0cc; }
    body{
      font-family:"Lora",serif; color:var(--ink);
      display:flex; flex-direction:column; gap:.5rem;
      background-image:url('background.png'); /* papel amassado */
      background-size: 260px 260px; background-repeat:repeat;
    }

    /* Header */
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:.6rem 1rem; border-bottom:3px solid var(--brown);
      background:rgba(255,255,255,.6); backdrop-filter: blur(2px);
    }
    .title{
      font-weight:700; letter-spacing:.3px; color:var(--brown);
    }
    .controls{ display:flex; align-items:center; gap:.6rem; }
    .btn{
      display:flex; align-items:center; gap:.5rem;
      background:#fff; border:2px solid var(--brown);
      border-radius:10px; padding:.35rem .7rem; cursor:pointer;
      user-select:none; transition:.15s transform ease;
      box-shadow: 1px 2px 0 var(--brown);
    }
    .btn:active{ transform: translateY(1px); box-shadow: 0 1px 0 var(--brown); }
    .btn img{ height:22px; width:auto; }
    .btn.play{ border-color:var(--orange); box-shadow: 1px 2px 0 var(--orange);}
    .btn.reset{ border-color:var(--turquoise); box-shadow: 1px 2px 0 var(--turquoise);}
    .btn.menu { border-color:var(--brown); }

    /* Main layout */
    .wrap{
      display:grid; grid-template-columns: 220px 1fr 240px; gap:12px;
      padding:12px; max-width:1200px; margin:0 auto; width:100%;
    }

    /* Toolbox */
    .toolbox{
      background:rgba(255,255,255,.7);
      border:3px solid var(--brown); border-radius:14px; padding:10px;
      box-shadow: 2px 3px 0 var(--brown);
    }
    .toolbox h2{ font-size:1.05rem; margin:.1rem 0 .5rem; color:#333; }
    .tool{
      border:2px dashed var(--brown); border-radius:12px; padding:10px;
      background:#fff; cursor:grab; user-select:none; margin-bottom:10px;
      display:flex; align-items:center; gap:.5rem; justify-content:space-between;
    }
    .tool:active{ cursor:grabbing; }
    .chip{
      font-size:.8rem; color:#fff; background:var(--orange);
      padding:.15rem .5rem; border-radius:999px; border:1px solid #d26e1f;
    }

    /* Canvas panel */
    .board{
      position:relative; border:3px solid var(--brown); border-radius:16px;
      background:rgba(255,255,255,.85);
      box-shadow: 2px 3px 0 var(--brown);
      overflow:hidden;
    }
    #game{
      display:block; width:100%; height:auto;
      background:transparent;
    }
    .hud{
      position:absolute; inset:0; pointer-events:none;
      font-size:.95rem; color:#333;
    }
    .hint{
      position:absolute; left:12px; top:12px; max-width:60%;
      background:rgba(255,255,255,.85); padding:.6rem .7rem;
      border:2px solid var(--turquoise); border-radius:10px;
      box-shadow: 2px 2px 0 var(--turquoise);
    }
    .hint kbd{
      border:1px solid #bbb; padding:0 .35rem; border-radius:6px;
      background:#fff; font-family:ui-monospace, monospace; font-size:.9em;
    }
    .banner{
      position:absolute; left:50%; top:16px; transform:translateX(-50%);
      background:#fff; border:3px solid var(--orange); color:#222;
      padding:.5rem .8rem; border-radius:12px; display:none;
      box-shadow: 2px 3px 0 var(--orange);
    }
    .banner.show{ display:block; }

    /* Side notes */
    .notes{
      background:rgba(255,255,255,.7);
      border:3px solid var(--brown); border-radius:14px; padding:10px;
      box-shadow: 2px 3px 0 var(--brown);
    }
    .notes h3{ margin:.1rem 0 .4rem; }
    .keyline{ color:#666; font-size:.95rem; line-height:1.3; }
    .badge{ color:#fff; background:var(--turquoise); padding:.1rem .45rem; border-radius:8px; }

    /* Tiny legend at bottom */
    footer{
      text-align:center; font-size:.85rem; color:#5b4a3f; opacity:.9; padding:8px 0 16px;
    }
  </style>
</head>
<body>

  <header>
    <div class="title">Inf√¢ncia do GPT ‚Äî <span style="color:var(--orange)">N√≠vel 0</span> (Tutorial)</div>
    <div class="controls">
      <button id="btnPlay" class="btn play"><img src="play_icon.png" alt="">Play</button>
      <button id="btnReset" class="btn reset">Reset</button>
      <button id="btnMenu" class="btn menu"><img src="diary_icon.png" alt="" />Menu</button>
    </div>
  </header>

  <div class="wrap">
    <!-- TOOLBOX -->
    <aside class="toolbox">
      <h2>Caixa de Ferramentas</h2>
      <div id="toolRamp" class="tool" draggable="false" title="Arraste para o campo">
        <div style="display:flex; align-items:center; gap:.55rem;">
          <svg width="46" height="28" viewBox="0 0 46 28" aria-hidden="true">
            <path d="M2 26 L42 26 L2 6 Z" fill="#e7c8a8" stroke="#8a5a3b" stroke-width="2"/>
            <path d="M4 25 L38 25 L4 8 Z" fill="none" stroke="#8a5a3b" stroke-width="1" stroke-dasharray="4 3"/>
          </svg>
          <b>Rampa</b>
        </div>
        <span class="chip">x1</span>
      </div>
      <p style="margin:.2rem 0 0; font-size:.85rem; color:#555;">
        Dica: posicione, depois gire com <kbd>Q</kbd>/<kbd>E</kbd>. <b>Shift</b> liga o <i>snap</i>.
      </p>
    </aside>

    <!-- BOARD -->
    <section class="board">
      <canvas id="game" width="960" height="600"></canvas>
      <div class="hud">
        <div id="hint" class="hint">
          <b>Objetivo:</b> fa√ßa a <span class="badge">Bola</span> cair dentro do <span class="badge">Balde</span> usando a <span class="badge">Rampa</span>.<br>
          1) Arraste a <b>Rampa</b> da caixa de ferramentas para o campo.<br>
          2) Gire com <kbd>Q</kbd>/<kbd>E</kbd> (segure <kbd>Shift</kbd> p/ <i>snap</i> de 15¬∞).<br>
          3) Clique <b>Play</b> e observe! Voc√™ pode reajustar e tentar de novo.
        </div>
        <div id="bannerWin" class="banner">üéâ Conseguiu! A bola est√° no balde.</div>
      </div>
    </section>

    <!-- NOTES -->
    <aside class="notes">
      <h3>Controles</h3>
      <div class="keyline">‚Ä¢ <b>Arrastar</b> a rampa da Toolbox para o campo.</div>
      <div class="keyline">‚Ä¢ <b>Rotacionar</b>: <kbd>Q</kbd>/<kbd>E</kbd> ‚Äî <em>snap</em> com <kbd>Shift</kbd>.</div>
      <div class="keyline">‚Ä¢ <b>Play</b> inicia a simula√ß√£o. <b>Reset</b> recome√ßa o n√≠vel.</div>
      <hr style="border:none;border-top:1px dashed #b98a6b; margin:.5rem 0;">
      <div class="keyline">Tentativas: <span id="tries">0</span> ‚Ä¢ Tempo: <span id="time">0.0s</span></div>
    </aside>
  </div>

  <footer>
    Est√©tica de colagem / giz: laranja, turquoise, marrom ‚Ä¢ Tipografia: Lora ‚Ä¢ Motor de f√≠sica: Matter.js (Canvas 2D)
  </footer>

<script>
/* =========================
   N√çVEL 0 ‚Äî TUTORIAL
   Matter.js + Canvas 2D (custom draw) ‚Äî coment√°rios em ingl√™s
========================= */

// --- Shorthands
const { Engine, World, Bodies, Body, Composite, Composites, Constraint, Events, Render, Runner, Vector, Mouse, MouseConstraint } = Matter;

// Canvas & 2D drawing
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// UI refs
const btnPlay = document.getElementById('btnPlay');
const btnReset = document.getElementById('btnReset');
const btnMenu = document.getElementById('btnMenu');
const bannerWin = document.getElementById('bannerWin');
const triesEl = document.getElementById('tries');
const timeEl  = document.getElementById('time');
const toolRamp = document.getElementById('toolRamp');

// Assets (images)
const imgBucket = new Image(); imgBucket.src = 'bucket.png';
const imgPlayTri = new Image(); imgPlayTri.src = 'play_icon.png'; // (used only in header)
const bgPaper = new Image(); bgPaper.src = 'background.png';

// Physics world
let engine, world, mouseConstraint;
let playing = false;
let levelStartTime = 0, timerInterval = null, tries = 0;

// Bodies we care about
let ball, shelf, bucketWalls = [], goalSensor;
let rampBody = null;     // placed ramp (player piece)
let placingRamp = null;  // ghost while placing
let selectedBody = null; // body under mouse

// Bucket drawing anchor (for the collage sprite)
const BUCKET_ANCHOR = { x: 760, y: 420 }; // top-left-ish for sprite
const BUCKET_SCALE  = 0.75;

// Utility: deg <-> rad
const toRad = (deg) => deg * Math.PI/180;
const toDeg = (rad) => rad * 180/Math.PI;

// ====== Init level ======
function setupLevel(){
  engine = Engine.create({ gravity: { x: 0, y: 1 } });
  world  = engine.world;

  // Static floor (invisible)
  const floor = Bodies.rectangle(480, 610, 960, 60, { isStatic: true, render: { visible:false }});
  World.add(world, floor);

  // Small shelf to hold the ball at start (static)
  shelf = Bodies.rectangle(170, 300, 180, 16, {
    isStatic: true,
    angle: toRad(-10),
    friction: .5, render: { visible:false }
  });
  World.add(world, shelf);

  // Ball (dynamic)
  ball = Bodies.circle(120, 260, 20, {
    restitution: 0.2, friction: 0.05, frictionAir: 0.01,
    label: 'ball'
  });
  World.add(world, ball);

  // Bucket: two side walls + base, and a sensor inside the bucket bottom
  // We'll align physics walls to match the sprite visually
  const bx = 800, by = 540;      // base center
  const wallH = 90, wallT = 12, innerW = 90;
  const leftWall  = Bodies.rectangle(bx - innerW/2, by - wallH/2, wallT, wallH, { isStatic:true, chamfer: 4, label:'bucket' });
  const rightWall = Bodies.rectangle(bx + innerW/2, by - wallH/2, wallT, wallH, { isStatic:true, chamfer: 4, label:'bucket' });
  const base      = Bodies.rectangle(bx, by, innerW, wallT, { isStatic:true, chamfer: 2, label:'bucket' });
  bucketWalls = [leftWall, rightWall, base];
  World.add(world, bucketWalls);

  // Sensor region (slightly above the base so the ball can "sit" in)
  goalSensor = Bodies.rectangle(bx, by - 10, innerW - 12, 20, {
    isStatic:true, isSensor:true, label:'goalSensor'
  });
  World.add(world, goalSensor);

  // Mouse + drag constraint for picking/dragging existing bodies (if needed)
  const mouse = Mouse.create(canvas);
  mouse.pixelRatio = window.devicePixelRatio || 1;
  mouseConstraint = MouseConstraint.create(engine, {
    mouse, constraint: { stiffness: 0.18, render:{ visible:false } }
  });
  World.add(world, mouseConstraint);

  // Track selection (useful for rotation)
  Events.on(mouseConstraint, 'startdrag', e => {
    selectedBody = e.body;
  });
  Events.on(mouseConstraint, 'enddrag', () => {
    selectedBody = null;
  });

  // Win detection: keep time while ball overlaps the sensor with low speed
  let inside = false, insideSince = 0;
  Events.on(engine, 'collisionActive', e => {
    if(!playing) return;
    e.pairs.forEach(p => {
      const a = p.bodyA, b = p.bodyB;
      if((a===ball && b===goalSensor) || (b===ball && a===goalSensor)){
        const speed = ball.speed;
        const now = performance.now();
        if(!inside){ inside = true; insideSince = now; }
        if(inside && speed < 0.3 && (now - insideSince) > 1000){
          showWin();
        }
      }
    });
  });
  Events.on(engine, 'collisionEnd', e => {
    e.pairs.forEach(p => {
      const a = p.bodyA, b = p.bodyB;
      if((a===ball && b===goalSensor) || (b===ball && a===goalSensor)){
        // left the sensor region ‚Äî reset "inside" timer implicitly by stopping the active check above
      }
    });
  });

  // Reset UI state
  bannerWin.classList.remove('show');
  tries = 0; triesEl.textContent = tries;
  levelStartTime = performance.now(); updateTimer(true);

  // Start render loop paused (we only advance physics when playing)
  requestAnimationFrame(loop);
}

function updateTimer(reset=false){
  if(reset && timerInterval){ clearInterval(timerInterval); }
  timerInterval = setInterval(()=>{
    if(!levelStartTime) { timeEl.textContent = "0.0s"; return; }
    const secs = (performance.now()-levelStartTime)/1000;
    timeEl.textContent = secs.toFixed(1)+"s";
  }, 100);
}

// ====== Toolbox logic: place ONE ramp ======
let rampAvailable = true;
let draggingFromTool = false;

toolRamp.addEventListener('pointerdown', (ev)=>{
  if(!rampAvailable) return;
  draggingFromTool = true;
  // Create a ghost ramp body following the mouse (static)
  const pos = screenToWorld(ev.clientX, ev.clientY);
  placingRamp = Bodies.rectangle(pos.x, pos.y, 180, 16, {
    isStatic: true,
    angle: toRad(-20),
    friction: .5,
    label:'piece_ramp',
    render: { visible:false }
  });
  World.add(world, placingRamp);
  toolRamp.style.opacity = .45;
  ev.preventDefault();
});

window.addEventListener('pointermove', (ev)=>{
  if(placingRamp){
    const pos = screenToWorld(ev.clientX, ev.clientY);
    Body.setPosition(placingRamp, pos);
  }
});
window.addEventListener('pointerup', (ev)=>{
  if(placingRamp){
    const pos = screenToWorld(ev.clientX, ev.clientY);
    // Only finalize if inside the canvas bounds
    const r = canvas.getBoundingClientRect();
    if(ev.clientX >= r.left && ev.clientX <= r.right && ev.clientY >= r.top && ev.clientY <= r.bottom){
      rampBody = placingRamp; // finalize
      placingRamp = null;
      rampAvailable = false;
      draggingFromTool = false;
      toolRamp.style.pointerEvents = 'none';
      toolRamp.querySelector('.chip').textContent = 'x0';
      toolRamp.title = 'Rampa j√° usada';
    }else{
      // cancel placement
      World.remove(world, placingRamp);
      placingRamp = null; draggingFromTool = false;
      toolRamp.style.opacity = 1;
    }
  }
});

// ====== Controls ======
btnPlay.addEventListener('click', ()=>{
  if(!playing){
    tries++; triesEl.textContent = tries;
    playing = true;
  }
});
btnReset.addEventListener('click', resetLevel);
btnMenu.addEventListener('click', ()=> alert('Menu (placeholder)'));

function resetLevel(){
  playing = false;
  Engine.clear(engine);
  World.clear(world, false);
  rampBody = null; placingRamp = null; selectedBody = null;
  rampAvailable = true;
  toolRamp.style.opacity = 1;
  toolRamp.style.pointerEvents = 'auto';
  toolRamp.querySelector('.chip').textContent = 'x1';
  bannerWin.classList.remove('show');
  levelStartTime = performance.now(); updateTimer(true);
  setupLevel();
}

function showWin(){
  playing = false;
  bannerWin.classList.add('show');
}

// ====== Rotation (Q/E) with Shift snap ======
window.addEventListener('keydown', (e)=>{
  // Prefer the ghost (placing) or the selected ramp, else ignore
  const target = placingRamp || (selectedBody && selectedBody.label==='piece_ramp') ? (placingRamp||selectedBody) : rampBody;
  if(!target) return;

  const snap = e.shiftKey ? 15 : 0; // deg
  if(e.key.toLowerCase() === 'q'){
    nudgeRotation(target, -5, snap);
  }else if(e.key.toLowerCase() === 'e'){
    nudgeRotation(target, +5, snap);
  }
});
function nudgeRotation(body, deltaDeg, snapDeg=0){
  const next = toDeg(body.angle) + deltaDeg;
  let rad = toRad(next);
  if(snapDeg){
    const snapped = Math.round(next / snapDeg) * snapDeg;
    rad = toRad(snapped);
  }
  Body.setAngle(body, rad);
}

// ====== Helpers ======
function screenToWorld(cx, cy){
  const r = canvas.getBoundingClientRect();
  return { x: cx - r.left, y: cy - r.top };
}

// ====== Main loop (custom render) ======
function loop(){
  // Advance physics only when "playing"
  if(playing){ Engine.update(engine, 1000/60); }

  // Clear canvas
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Optional faint grid
  drawGrid();

  // Draw shelf (wood plank)
  drawPlank(shelf.position.x, shelf.position.y, 180, 16, shelf.angle, '#e7c8a8');

  // Draw ramp (player piece)
  if(rampBody){ drawPlank(rampBody.position.x, rampBody.position.y, 180, 16, rampBody.angle, '#f1d9b8'); }
  if(placingRamp){ drawPlank(placingRamp.position.x, placingRamp.position.y, 180, 16, placingRamp.angle, 'rgba(241,217,184,.7)', true); }

  // Draw ball
  drawBall(ball.position.x, ball.position.y, 20);

  // Draw bucket sprite (collage)
  drawBucketSprite();

  // Debug: you can toggle to see physics shapes (commented)
  // debugPhysics();

  requestAnimationFrame(loop);
}

function drawGrid(){
  const step=40;
  ctx.save();
  ctx.globalAlpha = .18;
  ctx.beginPath();
  for(let x=0;x<=canvas.width;x+=step){
    ctx.moveTo(x,0); ctx.lineTo(x,canvas.height);
  }
  for(let y=0;y<=canvas.height;y+=step){
    ctx.moveTo(0,y); ctx.lineTo(canvas.width,y);
  }
  ctx.strokeStyle = '#a9cfcf'; // turquoise claro
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.restore();
}

function drawPlank(x,y,w,h,ang,fill,ghost=false){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(ang);
  // wood fill
  ctx.fillStyle = fill;
  ctx.strokeStyle = '#8a5a3b';
  ctx.lineWidth = 2;
  roundRect(ctx, -w/2, -h/2, w, h, 6);
  ctx.fill(); ctx.stroke();
  // hatching (hand-made vibe)
  ctx.globalAlpha = .25;
  ctx.beginPath();
  for(let i=-w/2+6;i<w/2-6;i+=10){
    ctx.moveTo(i,-h/2+3); ctx.lineTo(i+8, h/2-3);
  }
  ctx.strokeStyle = '#8a5a3b'; ctx.lineWidth = 1; ctx.stroke();
  ctx.globalAlpha = 1;
  // ghost dash
  if(ghost){
    ctx.setLineDash([6,6]);
    ctx.strokeStyle = '#20b2aa';
    ctx.lineWidth = 2;
    ctx.strokeRect(-w/2, -h/2, w, h);
    ctx.setLineDash([]);
  }
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawBall(x,y,r){
  ctx.save();
  ctx.translate(x,y);
  // chalky orange circle
  ctx.beginPath();
  ctx.arc(0,0,r,0,Math.PI*2);
  ctx.fillStyle = '#f3852e';
  ctx.fill();
  ctx.lineWidth = 3; ctx.strokeStyle = '#d26e1f'; ctx.stroke();
  // crayon texture
  ctx.globalAlpha = .25;
  for(let i=0;i<14;i++){
    ctx.beginPath();
    ctx.arc(0,0,r-2-i*0.8, Math.random()*Math.PI*2, Math.random()*Math.PI*2);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = .7;
    ctx.stroke();
  }
  ctx.restore();
}

function drawBucketSprite(){
  // Align the sprite visually with physics bucket
  const w = 300*BUCKET_SCALE, h = 300*BUCKET_SCALE;
  const x = BUCKET_ANCHOR.x, y = BUCKET_ANCHOR.y;
  ctx.save();
  ctx.drawImage(imgBucket, x, y, w, h);
  ctx.restore();
}

// Optional quick physics debug (wireframes)
function debugPhysics(){
  ctx.save();
  ctx.globalAlpha = .25;
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  drawBodyWire(shelf);
  if(rampBody) drawBodyWire(rampBody);
  bucketWalls.forEach(drawBodyWire);
  drawBodyWire(goalSensor);
  drawBodyWire(ball,true);
  ctx.restore();
}
function drawBodyWire(b, circle=false){
  if(circle){ // ball
    ctx.beginPath();
    ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, Math.PI*2);
    ctx.stroke();
    return;
  }
  const v = b.vertices;
  ctx.beginPath();
  ctx.moveTo(v[0].x, v[0].y);
  for(let i=1;i<v.length;i++) ctx.lineTo(v[i].x, v[i].y);
  ctx.closePath(); ctx.stroke();
}

// Boot
setupLevel();

</script>
</body>
</html>
